{"version":3,"file":"useDevicePortalOutput.js","sources":["../src/useDevicePortalOutput.ts"],"sourcesContent":["import { useMemo, useState, type Dispatch, type SetStateAction } from 'react'\nimport { Responder } from './webrtc/Responder'\n\n// @TODO: warn if one room is used by multiple useDevicePortalOutput hooks more than once at the same time\n\ntype State = {\n\troom: string\n\tvalue: string\n\tsendValueToInput: (value: string) => void\n}\n\nconst responders: {\n\t[room: string]: {\n\t\tresponder: Responder\n\t\tfirstValuePromise: Promise<string>\n\t\toutput: null | { value: string; sendValueToInput: (value: string) => void }\n\t\tsetValueState: Dispatch<SetStateAction<State>>\n\t}\n} = {}\n\nexport const useDevicePortalOutput = (\n\troom: string,\n\toptions?: {\n\t\twebsocketSignalingServer?: string\n\t},\n): Pick<State, 'value' | 'sendValueToInput'> => {\n\tconst [valueState, setValueState] = useState<State | null>(null)\n\tconst output = useMemo(() => {\n\t\tif (valueState === null || valueState.room !== room) {\n\t\t\treturn null\n\t\t}\n\t\treturn {\n\t\t\tvalue: valueState.value,\n\t\t\tsendValueToInput: valueState.sendValueToInput,\n\t\t}\n\t}, [])\n\n\tif (!responders[room]) {\n\t\tconst { promise: firstValuePromise, resolve: firstValueResolve } =\n\t\t\tPromise.withResolvers<string>()\n\t\tconst responder = new Responder(room, {\n\t\t\tonValue: (value) => {\n\t\t\t\tresponders[room].output = { value, sendValueToInput }\n\t\t\t\tresponders[room].setValueState({ room, value, sendValueToInput })\n\t\t\t\tfirstValueResolve(value)\n\t\t\t},\n\t\t\tsendLastValueOnConnectAndReconnect: false,\n\t\t\twebsocketSignalingServer: options?.websocketSignalingServer,\n\t\t})\n\t\tconst sendValueToInput = (value: string) => {\n\t\t\tresponder.send(value)\n\t\t}\n\t\tresponders[room] = {\n\t\t\tresponder,\n\t\t\tfirstValuePromise,\n\t\t\toutput: null,\n\t\t\tsetValueState,\n\t\t}\n\t}\n\tresponders[room].setValueState = setValueState\n\n\tif (output) {\n\t\treturn output\n\t}\n\tif (responders[room].output) {\n\t\treturn responders[room].output\n\t}\n\tthrow responders[room].firstValuePromise\n}\n"],"names":[],"mappings":";;;AAWA,IAAM,UAAU,GAOZ,EAAE;AAEO,IAAA,qBAAqB,GAAG,UACpC,IAAY,EACZ,OAEC,EAAA;IAEK,IAAA,EAAA,GAA8B,QAAQ,CAAe,IAAI,CAAC,EAAzD,UAAU,GAAA,EAAA,CAAA,CAAA,CAAA,EAAE,aAAa,GAAA,EAAA,CAAA,CAAA,CAAgC;IAChE,IAAM,MAAM,GAAG,OAAO,CAAC,YAAA;QACtB,IAAI,UAAU,KAAK,IAAI,IAAI,UAAU,CAAC,IAAI,KAAK,IAAI,EAAE;AACpD,YAAA,OAAO,IAAI;;QAEZ,OAAO;YACN,KAAK,EAAE,UAAU,CAAC,KAAK;YACvB,gBAAgB,EAAE,UAAU,CAAC,gBAAgB;SAC7C;KACD,EAAE,EAAE,CAAC;AAEN,IAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;QAChB,IAAA,EAAA,GACL,OAAO,CAAC,aAAa,EAAU,EADf,iBAAiB,GAAA,EAAA,CAAA,OAAA,EAAW,mBAAiB,GAAA,EAAA,CAAA,OAC9B;AAChC,QAAA,IAAM,WAAS,GAAG,IAAI,SAAS,CAAC,IAAI,EAAE;YACrC,OAAO,EAAE,UAAC,KAAK,EAAA;AACd,gBAAA,UAAU,CAAC,IAAI,CAAC,CAAC,MAAM,GAAG,EAAE,KAAK,EAAA,KAAA,EAAE,gBAAgB,EAAA,kBAAA,EAAE;AACrD,gBAAA,UAAU,CAAC,IAAI,CAAC,CAAC,aAAa,CAAC,EAAE,IAAI,EAAA,IAAA,EAAE,KAAK,EAAA,KAAA,EAAE,gBAAgB,EAAA,kBAAA,EAAE,CAAC;gBACjE,mBAAiB,CAAC,KAAK,CAAC;aACxB;AACD,YAAA,kCAAkC,EAAE,KAAK;AACzC,YAAA,wBAAwB,EAAE,OAAO,KAAA,IAAA,IAAP,OAAO,KAAP,MAAA,GAAA,MAAA,GAAA,OAAO,CAAE,wBAAwB;AAC3D,SAAA,CAAC;QACF,IAAM,kBAAgB,GAAG,UAAC,KAAa,EAAA;AACtC,YAAA,WAAS,CAAC,IAAI,CAAC,KAAK,CAAC;AACtB,SAAC;QACD,UAAU,CAAC,IAAI,CAAC,GAAG;AAClB,YAAA,SAAS,EAAA,WAAA;AACT,YAAA,iBAAiB,EAAA,iBAAA;AACjB,YAAA,MAAM,EAAE,IAAI;AACZ,YAAA,aAAa,EAAA,aAAA;SACb;;AAEF,IAAA,UAAU,CAAC,IAAI,CAAC,CAAC,aAAa,GAAG,aAAa;IAE9C,IAAI,MAAM,EAAE;AACX,QAAA,OAAO,MAAM;;AAEd,IAAA,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE;AAC5B,QAAA,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC,MAAM;;AAE/B,IAAA,MAAM,UAAU,CAAC,IAAI,CAAC,CAAC,iBAAiB;AACzC;;;;"}